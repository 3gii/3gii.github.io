<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[with与上下文管理器]]></title>
    <url>%2F2017%2F03%2F22%2Fpython-with%2F</url>
    <content type="text"><![CDATA[两种实现方法1）通过魔术属性 1234567891011121314class File(): def __init__(self, filename, mode): self.filename = filename self.mode = mode def __enter__(self): print("entering") self.f = open(self.filename, self.mode) return self.f def __exit__(self, *args): print("will exit") self.f.close() 2）通过装饰器 1234567from contextlib import contextmanager@contextmanagerdef my_open(path, mode): f = open(path, mode) yield f f.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>上下文管理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多继承]]></title>
    <url>%2F2017%2F03%2F17%2F%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[多继承及多层继承 在实际开发中如果这两个使用稍不当，就会出现各种问题，先看两个例子 12345678class A: passclass B(A): passclass C(B): pass 12class C(A, B): pass 在调用时按照MRO顺序调用C.__mro__或C.maro()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本操作]]></title>
    <url>%2F2017%2F02%2F11%2Fmysql%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346-- RDBMS(Relational Database Management System)-- 关系型数据库-- SQL 语句-- DQL: 数据查询语言，用于数据查询，select-- DML: 数据操作语言，insert、update、delete-- TPL: 事务处理语言，对事务进行处理，begin transaction、commit、rollback-- DCL: 数据控制语言，进行授权与权限回收，grant、revoke-- DDL: 数据定义语言，进行数据库、表的操作，create、drop-- CCL: 指针控制语言，通过指针完成表的操作，declare，cursor-- 常用操作: DQL、DML、DDL，CRUD(增删改查)-- MySQL 安装-- sudo apt-get install mysql-server-- sudo service mysql start 启动服务-- 查看进程中是否存在MySql服务-- ps ajx|grep mysql-- sudo service mysql stop 停止服务-- sudo service mysql restart 重启服务-- MySQL常用配置项-- 配置目录 /etc/mysql/mysql.conf.d/mysql.cnf-- bind-address: 表示服务器绑定的ip，默认为127.0.0.1-- port: 端口号，默认3306-- datadir: 表示数据库目录，默认为/var/lib/mysql-- general_log_file: 普通日志，默认为/var/log/mysql/mysql.log-- log_error: 错误日志，默认为/var/log/mysql/error.log-- 数据完整性-- 常见数据类型-- 数值类型-- 类型 字节大小 Signed Unsigned-- TINYINT 1 -128-127 0-255-- SMALLINT 2 -32768-32767 0-65535-- MEDIUMINT 3 -8388608-8388607 0-16777215-- INT/INTEGER 4 -2147483648-2147483647 0-4294967295-- BIGINT 8 -9223372036854775808-922337 0-18446744073709551615-- -2036854775807-- 字符串类型-- 类型 字节大小 说明-- CHAR 0-255 char(3) 输入"ab"，实际存储"ab "，输入"abcd"，实际存储"abc"-- VARCHAR 0-255 varchar(3)输入"ab"，实际存储"ab"，数据"abcd"，实际存储"abc"-- TEXT 0-65535 大文本-- 日期时间类型-- 类型 字节大小 示例-- DATE 4 '2020-01-01'-- TIME 3 '12:28:59'-- DATETIME 8 '2020-01-01 12:28:59'-- YEAR 1 '2017'-- TIMESTAMP 4 '1970-01-01 00:00:01'UTC ~ '2038-01-01 00:00:01'UTC-- 常用数据类型-- 整数: int、bit -- 小数: decimal 表示浮点数,如decimal(5,2)表示共有5位，小数占2位-- 字符串: varchar、char-- 日期时间: date、time、datetime-- 枚举类型: enum-- 常用约束-- 主键 primary key-- 非空 not null-- 唯一 unique-- 默认值 default-- 外键foreign key 不推荐使用，会降低数据库性能，数据的有效性交给逻辑层控制-- 数据库操作-- 连接数据库mysql -uroot -proot mysql -uroot -proot-- 退出数据库exit/quit/ctrl+d-- 显示数据库版本select version();-- 显示当前使用的数据库select database();-- 显示当前时间select now();-- 查看所有的数据库show databases;-- 创建数据库create database if not exists xxx charset=utf8;-- 查看创建数据库信息show create database xxx;-- 使用数据库use xxx;-- 删除数据库drop database xxx;-- 设置数据库字符编码alter database xxx charset set utf8;-- 数据库的备份与恢复mysqldump -uroot -p 数据库名 &gt; python.sql -- 数据库的备份mysql -uroot -p 新数据库 &lt; python.sql -- 数据库的恢复-- 修改提示符prompt python&gt;-- 导入数据库source d_name.sql;-- 数据表操作-- 查看当前数据库中所有的表show tables;-- 查看表结构desc t_xxx;-- 创建表create table students( id int unsigned primary key auto increment not null, name varchar(20) default '', age tinyint unsigned default 0, height decimal(5,2), gender enum('男', '女', '保密') default '保密', cls_id int unsigned default 0);-- 修改表-- 添加字段alter table students add birthday datetime;-- 修改字段 重命名alter table students change birthday birth datetime not null;-- 修改字段 不重命名alter table students modify birth date not null;-- 删除字段alter table students drop birthday;-- 删除表drop table students;-- 查看表创建语句select create table students;-- 添加数据insert into students values (0, '郭靖',1,'蒙古','2016-1-2');insert into students (id, name) values (1, '黄蓉')insert into students values (值,...),(值,...),...;-- 更新数据update students set gender=0,name='张三' where id=1;-- 删除记录delete from students where id=1;-- 查询记录select distinct * from 表名 where ... group by ... having ... order by ... limit start, count;-- 条件查询 -- 比较查询 select * from students where id&gt;3; -- 逻辑运算 select * from students where id&gt;3 and gender=0; -- 模糊查询 select * from students where name like '黄%'; select * from students where name like '黄_'; -- 范围查询 select * from students where id in(1,3,6); select * from students where id between 3 and 8; -- 空判断 select * from students where height is null; select * from students where height is not null;-- 排序 -- 升序 默认 select * from students order by id asc; -- 降序 select * from students order by id desc;-- 聚合函数 -- 总数 count() select count(*) from students; -- 最大值 max() select max(id) from students where gender=1; -- 最小值 min() select min(id) from students where gender=1; -- 求和 sum() select sum(age) from students where gender=1; select sum(age)/count(*) as 平均年龄 from students where gender=1; -- 求平均 avg() select avg(age) 平均年龄 from students where gender=1;-- 分组 -- group by select gender from students group by gender; -- 查询组内字段 select gender group_concat(name) from students group by gender; -- group by + having select gender, count(*) from students group by having count(*)&gt;2; -- group by + with rollup 在最后一行新增一行记录所有记录的总和 select gender, count(*) from students group by gender with rollup;-- 分页select * from students where gender=1 limit 0,3;select * from students where is_delete=0 limit (n-1)*m,m; -- n 当前页，m每页显示数目-- 连接查询 -- 内连接 inner join on select * from students inner join classes on students.cls_id = classes.id; -- 左连接 left join on select * from students as s left join classes as c on s.cls_id=c.id; -- 右连接 right join on select * from students as s right join classes as c on s.cls_id=c.id;-- 自关联-- 表之间自己与自己做关联查询-- 子查询select * from students where age &gt; (select avg(age) from students);select name from classes where id in (select cls_id from students);select * from students where (height, age) = (select max(height),max(age) from students);-- 将查询结果写入另一张表中insert into goods_cates(name) select cate_name from goods group by cate_name;-- 同步数据update goods as g inner join goods_cates as c on g.cate_name=c.name set g.cate_name=c.id;-- 外键alter table goods add foreign key (brand_id) references goods_brands(id);create table goods( id int primary key auto_increment not null, name varchar(40) default '', price decimal(5,2), cate_id int unsigned, brand_id int unsigned, is_show bit default 1, is_saleoff bit default 0, foreign key(cate_id) references goods_cates(id), foreign key(brand_id) references goods_brands(id));-- 查看外键名show create table goods;alter table goods drop foreign key 外键名;-- Python 操作数据库-- 查询-- from pymysql import *-- if __name__ == '__main__':-- conn = connect(host="localhost",port=3306,database='jing_dong',user='root',password='root',charset='utf8')-- cs = conn.cursor()-- cs.execute('select * from goods')-- print(cs.rowcount) # 最近一次执行execute()影响的行数-- print(cs.connection) # 当前的连接对象-- print(cs.fetchone()) # 一行数据-- print(cs.fetchall()) # 所有的数据 元组形式返回-- cs.close()-- conn.close()-- 添加，更新，删除-- count = cs.execute('delete from goods_cates where id in (2, 3)')-- print(count)-- # conn.rollback()-- conn.commit()-- 其它类似-- 参数化 -- params = ['硬盘'] -- count = cs.execute('insert into goods_cates (name) values ("%s")', params) -- # params = ('硬盘',) -- # count = cs.execute('insert into goods_cates (name) values ("&#123;&#125;")'.format(*params)) -- print(count)-- 视图操作-- 创建视图create view v_name as (select 子句)-- 查看视图show tables;-- 删除视图drop view v_name;-- 事务操作-- 事务的特点(ACID) -- 原子性 -- 一致性 -- 隔离性 -- 持久性-- 开启事务begin;start transaction;-- 提交事务commit;-- 回滚事务rollback;--- mysql 默认自动提交事务，关闭自动提交set autocommit = 0;-- 索引-- 创建索引create index i_name on t_name(字段名(长度))-- 查看索引show index from t_name;-- 删除索引drop index i_name on t_name;-- 时间监听-- 开启时间监听set profiling = 1;-- 查看监听时间show profiles;-- 权限管理-- 查看所有用户use mysql;desc user;-- 创建账户&amp;授权grant 权限列表 on 数据库 to '用户名'@'访问主机' identify by '密码'eg: grant select on python.* to 'laowang'@'localhost' identify by '123456';-- 可以查看python 数据库的所有表-- 查看用户权限show grant for laowang@localhost;-- 创建一个可远程连接的用户grant all privileges on python.* to 'laowang'@'%' identify by '123456';-- 修改用户权限grant 权限名 on 数据库 to 账号@主机 with grant option;-- 修改密码update user set authentication_string=password('新密码') where user='用户名';-- 低版本用password字段flush privileges; -- 修改完刷新权限-- 配置远程登录-- 在MySQL配置目录(/etc/mysql/mysql.conf.d/mysql.cnf)-- 注释掉bind-address = 127.0.0.1-- 重启MySQL service mysql restart-- 删除账户drop user '用户名'@’主机';delete from user where user='用户名';-- 刷新权限 flush privileges]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[property属性]]></title>
    <url>%2F2017%2F01%2F21%2Fproperty%2F</url>
    <content type="text"><![CDATA[两种实现方法1）装饰器 1234567891011121314151617181920212223242526class Goods(object): def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_priceobj = Goods()obj.price # 获取商品价格obj.price = 200 # 修改商品原价del obj.price # 删除商品原价 2）类属性方式 123456789101112131415161718192021222324# property属性的第二种定义方式:类属性定义方式class Goods(object): def get_price(self): print("get price...") return 100 def set_price(self, value): """必须两个参数""" print("set price...") print(value) def del_price(self): print("del price") price = property(get_price, set_price, del_price, "相关描述...")obj = Goods()obj.price # 自动调用第一个参数中定义的方法：get_priceobj.price = "价格" # 自动调用第二个参数中定义的方法：set_price方法，并将“价格”当作参数传入desc = Goods.price.__doc__ # 自动获取第四个参数中设置的值："相关描述..."print(desc)del obj.price # 自动调用第三个参数中定义的方法：del_price方法]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python类属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术属性]]></title>
    <url>%2F2017%2F01%2F21%2F%E9%AD%94%E6%9C%AF%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[魔法属性1.__doc__ 表示类的描述信息 1234567class Foo: """ 描述类信息，这是用于看片的神奇 """ def func(self): passprint(Foo.__doc__)#输出：类的描述信息 2.__module__和__class__ module 表示当前操作的对象在那个模块 class 表示当前操作的对象的类是什么 123456789101112test.py# -*- coding:utf-8 -*-class Person(object): def __init__(self): self.name = &apos;laowang&apos;main.pyfrom test import Personobj = Person()print(obj.__module__) # 输出 test 即：输出模块print(obj.__class__) # 输出 test.Person 即：输出类 3.__dict__ 类或对象中的所有属性 类的实例属性属于对象；类中的类属性和方法等属于类，即： 12345678910111213141516171819202122class Province(object): def __init__(self, name, count): self.name = name self.count = count def func(self, *args, **kwargs): print('func')# 获取类的属性，即：类属性、方法、print(Province.__dict__)# 输出：&#123;'__dict__': &lt;attribute '__dict__' of 'Province' objects&gt;, '__module__': '__main__', 'country': 'China', '__doc__': None, '__weakref__': &lt;attribute '__weakref__' of 'Province' objects&gt;, 'func': &lt;function Province.func at 0x101897950&gt;, '__init__': &lt;function Province.__init__ at 0x1018978c8&gt;&#125;obj1 = Province('山东', 10000)print(obj1.__dict__)# 获取 对象obj1 的属性# 输出：&#123;'count': 10000, 'name': '山东'&#125;obj2 = Province('山西', 20000)print(obj2.__dict__)# 获取 对象obj2 的属性# 输出：&#123;'count': 20000, 'name': '山西'&#125; 4.__init__ 初始化方法，通过类创建对象时，自动触发执行 1234567class Person: def __init__(self, name): self.name = name self.age = 18obj = Person('laowang') # 自动执行类中的 __init__ 方法 5.__del__ 当对象在内存中被释放时，自动触发执行。 注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，del的调用是由解释器在进行垃圾回收时自动触发执行的。 123class Foo: def __del__(self): pass 6.__str__ 如果一个类中定义了str方法，那么在打印 对象 时，默认输出该方法的返回值。 12345678class Foo: def __str__(self): return 'laowang'obj = Foo()print(obj)# 输出：laowang 7.__call__ 对象后面加括号，触发执行。 注：init方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 call 方法的执行是由对象后加括号触发的，即：对象() 或者 类()() 12345678910class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__')obj = Foo() # 执行 __init__obj() # 执行 __call__ 8、__getitem__、__setitem__、__delitem__ 用于索引操作，如字典。以上分别表示获取、设置、删除数据 12345678910111213141516171819# -*- coding:utf-8 -*-class Foo(object): def __getitem__(self, key): print('__getitem__', key) def __setitem__(self, key, value): print('__setitem__', key, value) def __delitem__(self, key): print('__delitem__', key)obj = Foo()result = obj['k1'] # 自动触发执行 __getitem__obj['k2'] = 'laowang' # 自动触发执行 __setitem__del obj['k1'] # 自动触发执行 __delitem__ 9、__getslice__、__setslice__、__delslice__ 该三个方法用于分片操作，如：列表 123456789101112131415161718# -*- coding:utf-8 -*-class Foo(object): def __getslice__(self, i, j): print('__getslice__', i, j) def __setslice__(self, i, j, sequence): print('__setslice__', i, j) def __delslice__(self, i, j): print('__delslice__', i, j)obj = Foo()obj[-1:1] # 自动触发执行 __getslice__obj[0:1] = [11,22,33,44] # 自动触发执行 __setslice__del obj[0:2] # 自动触发执行 __delslice__]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python类属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的数字]]></title>
    <url>%2F2017%2F01%2F11%2Fnumber%2F</url>
    <content type="text"><![CDATA[Python中的数字 在Python2中整型数据，分整型和长整型，而在Python3中只有整型 Python中的进制 整型可编写为十进制、二进制、八进制以及十六进制 十六进制以0x或0X开头，后面跟十六进制的数字0-9和A-F，不区分大小写 八进制以0o或0O开头，后面接0-7，在Python2.6及更早的版本中，八进制常量也可以写成前面只有一个0的形式，但在Python3中需要采用0o的形式 Python2.6和Python3.0中的新的二进制常量，以0b或0B开头 注意：所有的这些常量在程序代码中都产生一个整数对象。它们仅仅是特定值得不同语法表示而已，内置函数hex(I)、oct(I)和bin(I)把一个整型转换为这三种进制表示的字符串，int(str, base) 根据每个给定的进制把一个运行时字符串转换为一个整数。 关于除法 在Python2中/表示传统除法，如果两个操作数都是整数的话，执行截断整数除法即Floor除法。否则执行浮点除法（正真除法） 在Python3中/总是执行正真除法，//执行Floor除法 注意：//操作符通常叫做截断除法，但是，更准确的说法是floor除法，它把结果向下截断到下层，即真正结果之下的最近的整数，其直接效果是向下舍入，并不是严格的截断。区别如下 12345import mathmath.floor(2.5) # 2math.floor(-2.5) # -3math.trunc(2.5) # 2math.trunc(-2.5) # -2 在Python3中 123456&gt;&gt;&gt; (5/2), (5/2.0), (5/-2.0), (5/-2)(2.5, 2.5, -2.5, -2.5)&gt;&gt;&gt; (5//2), (5//2.0), (5//-2.0), (5//-2)(2, 2.0, -3.0, -3)&gt;&gt;&gt; (9/3), (9.0/3), (9//3), (9//3.0)(3, 3.0, 3, 3.0) 在Python2中 123456&gt;&gt;&gt; (5/2), (5/2.0), (5/-2.0), (5/-2)(2.5, 2.5, -2.5, -3)&gt;&gt;&gt; (5//2), (5//2.0), (5//-2.0), (5//-2)(2, 2.0, -3.0, -3)&gt;&gt;&gt; (9/3), (9.0/3), (9//3), (9//3.0)(3, 3.0, 3, 3.0) 内置数学工具123456789101112# 省略结果&gt;&gt;&gt; import math&gt;&gt;&gt; math.pi, math.e&gt;&gt;&gt; math.sin(2*math.pi/180)&gt;&gt;&gt; math.sqrt(144)&gt;&gt;&gt; pow(2, 4) # 2 ** 4&gt;&gt;&gt; abs(-42.0), sum((1, 2, 3))&gt;&gt;&gt; import random&gt;&gt;&gt; random.randow()&gt;&gt;&gt; random.randint(1, 10)&gt;&gt;&gt; random.choice([1, 2, 3]) Random模块很实用，在游戏中的发牌，在演示GUI中的随机图片、进行统计仿真等都需要Random模块 设置全局精度1234&gt;&gt;&gt; import decimal&gt;&gt;&gt; decimal.Decimal(1)/decimal.Decimal(7)&gt;&gt;&gt; decimal.getcontext().prec = 2&gt;&gt;&gt; pay = decimal.Decimal(str(1999 + 1.33)) 小数上下文管理器12345&gt;&gt;&gt; import decimal&gt;&gt;&gt; decimal.Decimal('1.00') / decimal.Decimal('3.00')&gt;&gt;&gt; with decimal.localcontext(): ctx.prec = 2 decimal.Decimal('1.00') / decimal.Decimal('3.00') 分数类型12&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; x = Fraction(1, 3) # 1/3 关于其中的精度问题以后做讨论]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python数据类型</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Python2到Python3]]></title>
    <url>%2F2017%2F01%2F10%2Fpy2-py3%2F</url>
    <content type="text"><![CDATA[Python2与Python3中的扩展 这里只是列出部分变化，并不对其用法进行详细说明 Python3.0中的print函数 Python3.0中的nonlocal x, y语句 Python2.6和Python3.0中的str.format方法 Python3.0中的字符串类型：str用于Unicode文本，bytes用于二进制数据 Python2.6和Python3.0中的类装饰器：@private(‘age’) Python3.0中的新的迭代器：range、map、zip Python3.0中的字典视图：D.keys、D.values、D.items Python3.0中的除法运算：余数、/和// Python3.0中的集合常量：{a, b, c} Python3.0中的集合解析：{x**2 for x in seq} Python3.0中的字典解析：{x: x**2 for x in seq} Python2.6和Python3.0中的二进制位字符串支持：0b0101，bin(I) Python3.0中的函数注释：def f(a:99, b:str) -&gt; int Python3.0中的Keyword-only参数：def f(a, *b, c, **d) Python3.0中的扩展的序列分解：a，*b = seq Python3.0中的可用的针对包的导入语法：from Python2.6和Python3.0中可用的环境管理器：with/as Python3.0中的异常语法修改：raise、except/as、superclass Python3.0中的异常链：raise e2 from e1 Python2.6和Python3.0中的保留字的变化 Python3.0中的新式类的取消 Python2.6和Python3.0中的特性装饰符：@property Python2.6和Python3.0中的描述符 Python2.6和Python3.0中的抽象基类 Python3.0语言中的删除 删除 替代 class MyException: class MyException(Exception) exceptions module 内置作用域，库手册 thread、Queue modules _thread, queue(二者都改名了) anydbm module dbm(改名了) cPickle module _pickle(改名了，自动使用) os.popen2/3/4 subprocess.Popen(os.popen保留) 基于字符串的异常 基于类的异常（Python2.6中也是如此） 字符串模块函数 字符串对象方法 未绑定方法 函数（通过实例调用静态方法） 混合类型比较、排序 非数字的混合类型比较是错误 pint &gt;&gt; F, x, y print(x, y file=F) print x, y, print(x, y end=’ ‘) u’ccc’ ‘ccc’ ‘bbb’ for byte strings b ‘bbb’ b’bbb’ raise E, V raise E(V) except E, X except E as X: def f((a, b)): def f(x): (a, b) = x file.xreadlines for line in file: (or X=iter(file)) D.keys()等 list(D.keys())(字典视图) map(), range(), etc. list(map()), list(range()) as lists (内置函数) map(None, …) zip(或手动代码来补充结果) X = D.keys(); X.sort() sorted(D) (或list(D.keys())) cmp(x, y) (x &gt; y) - (x &lt; y) X.__cmp__(y) __lt__、__gt__、、__eq__等 X__nonzero__ X__bool__ X.__hex__ ，X.__oct__ X.__index__ 排序比较函数 使用key=transform或reverse=True Dictionary &lt;, &gt;, &lt;=, &gt;= Compare sorted(D.items())(或循环代码) types.ListType list(type只用于非内建名称) __metaclass__ = M class C(metaclass=M): __builtin__ builtins(重命名) Tkinter tkinter(重命名) sys.exc_type、exc_value sys.exc_info()[0], [1] function.func_code function.__code__ 由内置函数运行的 在包装类中重定义__X__方法 __getattr__ -t,__tt命令行切换 不一致地使用制表符/空格总是一个错误 一个函数中的from… * 只能够出现在一个文件的顶层 导入模块，在同一包中 from . import mod . 包相关的形式]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python2</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络编程]]></title>
    <url>%2F2016%2F03%2F21%2Fpython_web%2F</url>
    <content type="text"><![CDATA[1. 网络编程1) IP地址 私有IP地址 10.0.0.0 - 10.255.255.255172.16.0.0 - 172.31.255.255192.168.0.0 - 192.168.255.255 本机IP地址127.0.0.1 localhost 2) 套接字 socket 是进程间通信的一个工具，它能实现将数据从一方传输到另一方，完成不同电脑上进程之间的通信，好比数据的搬运工。 3) 编码和解码 编码str -&gt; bytes: encode(encoding=”utf-8”, errors=”strict”) errors 还可以取ignore 表示在编解码不成功时忽略 解码bytes -&gt; str: decode(encoding=”utf-8”, errors=”strict”) 4) UDP协议（用户数据报协议） 特点 无连接双方在进行通信时，不需要相互建立连接 不可靠没有流量控制，发送方不会考虑接收方是否接受成功。 资源开销小，传输速度快 面向数据报的传输层协议 数据传输 12345678910111213141516171819202122232425262728import socket# 创建UDP套接字udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 创建目标地址address = ('192.168.138.29', 7878)# 设置需要发送的数据data = 'hello world'# 编码data = data.encode()# 发送数据udp_socket.sendto(data, address)# 接受数据recv_data, ip_port = udp_socket.recvfrom(1024)print(ip_port)# 解码recv_data = recv_data.decode('gbk')print(recv_data)# 关闭套接字udp_socket.close() 绑定端口 12local_addr = ('', 7788)udp_socket.bind(local_addr) 发送广播消息 12345678910111213141516171819202122232425262728293031import socket# 创建UDP套接字udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 创建目标地址address = ('192.168.138.255', 7878)# 设置socket允许发送广播消息udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)# 设置需要发送的数据data = 'hello world'# 编码data = data.encode()# 发送数据udp_socket.sendto(data, address)# 接受数据recv_data, ip_port = udp_socket.recvfrom(1024)print(ip_port)# 解码recv_data = recv_data.decode('gbk')print(recv_data)# 关闭套接字udp_socket.close() 5) TCP协议（传输控制协议） 特点 面向连接双方在通信前必须先建立连接 可靠传输 发送应答机制TCP发送的每个报文段必须得到对方的应答才认为这个TCP报文传输成功 超时重传机制发送端发出一个报文之后就开启定时器，如果在给定时间内没有得到应答，发送方就会重新发送这个报文段 流量控制TCP有相应的流量控制机制，比如滑动窗口 传输速度慢、资源开销大、适合大量数据传输 建立连接 三次握手 第一次客户端发送建立连接的请求，SYN=1, 产生随机的一个序列号seq=J ACK=1 发送个服务端，进入SYN_SENT状态 第二次服务端收到客户端发送的数据，通过SYN=1知道是要建立连接，服务端将SYN 和 ACK都置为1，并产生一个随机的序列号seq=K，ack=J+1 发送给客户端，进入SYN_RCVD状态 第三次客户端接收到数据后，先检查ack是否等于J+1，ACK是否等于1，如果正确，就将ACK=1,将ack=K+1 发送给服务端，服务端接收到数据，并检查后双方建立连接，进入ESTABLISHED状态 断开连接 四次挥手 第一次客户端发送FIN=1，seq=u，ACK=1 进入FIN-WAIT-1 第二次服务端收到后发送ACK=1，seq=v，ack=u+1 客户端进入FIN-WAIT-2 服务端进入CLOSE-WAIT 第三次服务端将ACK=1，FIN=1，ACK=1，seq=w，ack=u+1 进入LAST_ACK 第四次客户端收到服务端连接释放报文后，必须发出确认ACK=1，ack=w+1，seq=u+1，并进入TIME-WAIT 服务端收到后进入CLOSED状态客户端等待2MSL后进入CLOSED状态 数据传输 客户端 123456789101112131415161718192021222324252627# 创建TCP套接字tcp_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接server_ip = '192.168.138.29'server_port = 7878tcp_client.connect((server_ip, server_port))# 设置数据data = 'hello'# 编码data = data.encode()# 发送数据tcp_client.send(data)# 接受数据recv_data = tcp_client.recv(1024)# 解码recv_data = recv_data.decode('gbk')print(recv_data)# 关闭连接tcp_client.close() 服务器端 123456789101112131415161718192021222324252627282930313233343536# 创建TCP套接字tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 设置立即释放端口tcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)# 绑定地址tcp_server.bind(('', 7878))# 设置监听tcp_server.listen(128)# 接受客户端请求tcp_client, ip_port = tcp_server.accept()print(ip_port)# 接受数据recv_data = tcp_client.recv(1024)# 解码recv_data = recv_data.decode('gbk')print(recv_data)# 设置数据data = 'hello'# 编码data = data.encode()# 发送数据tcp_client.send(data)# 关闭连接tcp_client.close()tcp_server.close() 断开连接 当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线 2. 多任务 并发指的是任务数多于CPU核数，通过操作系统的各种调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已） 并行指的是任务数小于等于cpu核数，即任务真的是一起执行的 3. 线程1) 概念 线程就是在程序运行过程中，执行程序代码的一个分支，每个运行的程序至少都有一个线程。 2) 线程类Thread Thread(group, [target, [name [args, [kwargs]]]]) group: 线程组，目前只能使用None target: 执行的目标任务名 args: 以元组的形式给执行任务传参数 kwargs: 以字典的方式给执行任务传参 name: 线程名 3) 多线程 12345678910111213141516import threadingdef sing(): for i in range(10): print('sing', i) def dance(): for i in range(10): print('dance', i)sub_thread1 = threading.Thread(target=sing)sub_thread2 = threading.Thread(target=dance)sub_thread1.start()sub_thread2.start() 查看活动线程列表threading.enumerate() 获取活动线程的数量 threading.active_count() 提示： 线程启动后才会把线程放到活动线程列表里 线程执行完就会销毁，会从活动线程列表里移除这个线程对象 4) 传参 args=(&#39;zhangsan&#39;, 18) kwargs={&#39;name&#39;:&#39;zhangsan&#39;, age:18} 5) 设置守护主线程 Thread(daemon=True) sub_thread.daemon = True 6) 多线程的特点 线程之间执行是无序的 主线程会等待所有的子线程结束后才结束 线程之间共享变量 7) 自定义线程 123456789101112131415161718192021222324class MyThread(threading.Thread): """自定义线程""" def __init__(self, info1, info2): super(MyThread, self).__init__() self.info1 = info1 self.info2 = info2 def test1(self): print(self.info1) def test2(self): print(self.info2) def run(self): self.test1() self.test2()if __name__ == '__main__': my_thread = MyThread('测试1', '测试2') my_thread.start() 自定义线程不能指定target，因为自定义线程里面的任务都是统一在run方法里面执行 启动线程统一调用start方法，不要直接调用run方法，因为这样不是使用子线程去执行任务 8) 共享变量 解决共享变量出现数据错误的方法 线程同步: 保证同一时刻只能有一个线程去操作变量 实现线程同步的方法 线程等待(join) 123456789101112131415161718192021g_num = 0def sum_num1(): for i in range(1000000): global g_num g_num +=1 print('sum1:', g_num)def sum_num2(): for i in range(1000000): global g_num g_num +=1 print('sum2:', g_num)if __name__ == '__main__': sub1 = threading.Thread(target=sum_num1) sub2 = threading.Thread(target=sum_num2) sub1.start() sub1.join() sub2.start() 互斥锁 1234567891011121314151617181920212223242526lock = threading.Lock()g_num = 0def sum_num1(): lock.acquire() for i in range(1000000): global g_num g_num +=1 print('sum1:', g_num) lock.release()def sum_num2(): lock.acquire() for i in range(1000000): global g_num g_num +=1 print('sum2:', g_num) lock.release()if __name__ == '__main__': sub1 = threading.Thread(target=sum_num1) sub2 = threading.Thread(target=sum_num2) sub1.start() sub2.start() 死锁 避免出现死锁的方法: 注意在适当的位置加锁和释放锁，使用try...finally .. 4. 进程1) 概念 进程是系统进行资源分配的基本单位，每启动一个进程操作系统都需要为其分配运行资源 2) 进程状态 3) 进程与线程的关系 一个进程默认有一个线程，进程里可以创建线程，线程是依附在进程里面的，没有进程就没有线程 4) Process进程类 Process([group [, target [, name [, args [, kwargs]]]]]) group：指定进程组，目前只能使用None target：执行的目标任务名 name：进程名字 args：以元组方式给执行任务传参 kwargs：以字典方式给执行任务传参 Process创建的实例对象的常用方法 start()：启动子进程实例（创建子进程） join([timeout])：是否等待子进程执行结束，或等待多少秒 terminate()：不管任务是否完成，立即终止子进程 Process创建的实例对象的常用属性： name：当前进程的别名，默认为Process-N，N为从1开始递增的整数 pid：当前进程的pid（进程号） 5) 多进程 12345678910111213141516171819202122232425262728293031323334353637import osimport multiprocessingfrom time import sleepdef work(): current = multiprocessing.current_process() print('子进程', current) print('子进程号', multiprocessing.current_process().pid, os.getpid()) print('父进程号', os.getppid()) for _ in range(10): print('work...') sleep(1) os.kill(os.getpid(), 9)if __name__ == '__main__': current = multiprocessing.current_process() print('main', current, current.pid) sub_process = multiprocessing.Process(target=work) sub_process.start() for _ in range(10): print('main work......') sleep(1) 6) 多进程的特点 进程之间不共享变量 主进程会等待所有子进程全部结束后再退出 可以通过设置sub_process.terminate()结束子进程的执行 可以设置守护主进程 7) 进程池 1234567891011121314151617181920212223242526import multiprocessingimport timedef work(): print('复制中...', multiprocessing.current_process().pid) time.sleep(1)if __name__ == '__main__': pool = multiprocessing.Pool(3) # 超过CPU核数时，不会多分配 for i in range(5): # pool.apply(work) # 采用同步 pool.apply_async(work) # 采用异步 pool.close() pool.join() 进程池会根据任务量尽量少的分配进程 8) 进程间通信 1234567891011121314151617181920212223242526import multiprocessingif name == 'main': queue = multiprocessing.Queue(3) queue.put('zhangsan') queue.put([1, 2, 3]) queue.put(1) print(queue.full()) print('当前队列中消息数', queue.qsize()) print(queue.get()) print('当前队列中消息数', queue.qsize()) print(queue.get()) print('当前队列中消息数', queue.qsize()) print(queue.get()) print('当前队列中消息数', queue.qsize()) 说明初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）； Queue.qsize()：返回当前队列包含的消息数量； Queue.empty()：如果队列为空，返回True，反之False , 注意这个操作是不可靠的。 Queue.full()：如果队列满了，返回True,反之False； Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常； 2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常； Queue.get_nowait()：相当Queue.get(False)； Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True； 1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常； 2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常；Queue.put_nowait(item)：相当Queue.put(item, False)； 5. 协程1）概念 协程又称微线程，纤程，也称为用户级线程，在不开辟线程的基础上完成多任务，也就是在单线程的情况下完成多任务，多个任务按照一定的顺序交替执行，通俗理解只要在函数中定义了yield关键字表示就是协程 2）实现 简单实现 123456789101112131415161718192021import timedef work1(): while True: print('work1') yield time.sleep(0.5) def work2(): while True: print('work2') yield time.sleep(0.5)def main(): w1 = work1() w2 = work2() while True: next(w1) next(w2)if __name__ == '__main__': main() greenlet 12345678910111213141516171819import timeimport greenletdef work1(): while True: print('work1') time.sleep(0.5) g2.swith() def work2(): while True: print('work2') time.sleep(0.5) g1.switch()if __name__ == '__main__': g1 = greenlet.greenlet(work1) g2 = greenlet.greenlet(work2) g1.switch() gevent 1234567891011121314151617181920212223242526272829303132import geventimport timefrom gevent import monkey# 打补丁，让gevent框架识别耗时操作，比如：time.sleep，网络请求延时monkey.patch_all()# 任务1def work1(num): for i in range(num): print("work1....") time.sleep(0.2) # gevent.sleep(0.2)# 任务1def work2(num): for i in range(num): print("work2....") time.sleep(0.2) # gevent.sleep(0.2)if __name__ == '__main__': # 创建协程指定对应的任务 g1 = gevent.spawn(work1, 3) g2 = gevent.spawn(work2, 3) # 主线程等待协程执行完成以后程序再退出 g1.join() g2.join() 注意点 协程默认是开启守护的，在执行时需要阻塞，如果程序不会退出，则不用 6）线程、进程和协程之间的比较 一个进程至少有一个线程，进程里面可以有多个线程 一个线程里面可以有多个协程 进程是CPU资源分配的单位 线程是操作系统调度的单位 7）HTTP协议 http及https后续补上]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python容易被忽略的点]]></title>
    <url>%2F2016%2F03%2F11%2Fpython_other%2F</url>
    <content type="text"><![CDATA[列表1) 列表推导式[i for in range(10) if i%2 == 0] 2) 采用列表推导式对每一个元素调用同一方法 12freshfruit = ['banana', 'loganberry', 'passion fruit'][weapon.strip() for weapon in freshfruit] 集合1) 集合推导式x for x in &#39;abcsdjehgdg&#39; if x not in &#39;abc&#39; 字典1) 字典在进行比较时，只比较其键值 2) 对字典直接进行遍历时得到时键值 元组、集合、列表、字典1) 列表与元组 1234lt = [('name', 'zhangsan'), ('age', 18)]dict(lt)# 结果为 &#123;"name": 'zhangsan', 'age': 18&#125;# 集合与元组、元组与元组同理 2) 字典转化成元组、列表或集合 只转化相应的键值 类 Python中类的概念借鉴于Smalltalk，类就是一组用来描述和如何生成一个对象的代码段。 类本身也是一个对象，可以拷贝，可以添加属性，也可以作为函数参数进行传递。 1）动态生成类 通过函数返回类 12345678910def choose_class(name): if name == 'foo': class Foo(object): pass return Foo # 返回的是类，不是类的实例 else: class Bar(object): pass return BarMyClass = choose_class('foo') 通过type函数构造类 type(类名，父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）) 2）元类 元类是用来创建类对象的，type就是python内置的元类 __metaclass__属性 12345class Foo(object): __metaclass__ = something # python2class Foo(metaclass=something): __metaclass__ = something # python3 12class Foo(Bar): pass 类在定义时，并没有在内存中生成，直到它被调用。Python做了如下的操作： Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象 如果Python没有找到__metaclass__,它会继续在父类中找__metaclass__属性，并尝试做和之前同样的操作。 如果Python在任何父类中都找不到__metaclass__,它就会在模块层次中去寻找__metaclass__,并尝试做同样的操作， 如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象 3）自定义元类 使用函数当做元类 12345678910111213141516171819202122# 元类会自动将你通常传给type的参数作为自己的参数传入def upper_attr(future_class_name, future_class_parents, future_class_attr): """返回一个类对象， 将属性都转为大写形式""" # 选择所有不以“__”开头的属性 attrs = ((name ,value) for name, value in future_class_attr.items() if not name.startswith("__")) # 将它们转为大写形式 uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 通过type来做类对象的创建 return type(future_class_name, future_class_parents, uppercase_attr)class Foo(object): # py3 metaclass=upper_attr __metaclass__ = upper_attr bar = 'bip' print hasattr(Foo, 'bar')# 输出: Falseprint hasattr(Foo, 'BAR')# 输出:True f = Foo()print f.BAR# 输出:'bip' 使用class当做元类__metaclass__必须返回一个类 123456789101112# 请记住，'type'实际上是一个类，就像'str'和'int'一样。所以，你可以从type继承# __new__ 是在__init__之前被调用的特殊方法，__new__是用来创建对象并返回之的方法，__new_()是一个类方法# 而__init__只是用来将传入的参数初始化给对象，它是在对象创建之后执行的方法。# 你很少用到__new__，除非你希望能够控制对象的创建。这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__# 如果你希望的话，你也可以在__init__中做些事情。还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用，下面我们可以单独的讨论这个使用class UpperAttrMetaClass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__')) uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 返回一个对象，但同时这个对象是一个类 return type(future_class_name, future_class_parents, uppercase_attr) 但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的new方法。现在让我们这样去处理: 12345class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith('__') uppercase_attr = dict((name.upper(), value) for name, value in attrs) return type.__new__(cls, name, bases, uppercase_attr) 使用super 12345class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith('__')) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的基础]]></title>
    <url>%2F2016%2F03%2F11%2Fpython_base%2F</url>
    <content type="text"><![CDATA[1. Python中的编码Python2中默认的编码格式是ASCII格式，在读取中文时会报错，解决方案 在文件开头加入# -*- coding: utf-8 -*-或者#coding=utf-8 注意：第二种方式=两边不能有空格 在Pycharm里设置文件的编码 file&gt;Settings&gt;Editor&gt;File encodings 2. 设置文件可执行 文件开头添加#!/usr/bin/pythn 文件开头添加#!/usr/bin/env python 3. 语法规则 在同一行写多条语句时用;隔开 4. 数据类型1) 数字类型 int 在Python2.2以后的版本中，int类型数据溢出后会自动转为long类型。在Python3中long类型被移除，用int代替 float complex3.14+5j bool Python2中没有bool类型，它用数字0表示False，用1表示True。在Python3中，True和False被定义成关键字，但值依然是1和0，可以和数字相加。 2) 非数字类型 str tuple list dict 字典的键必须唯一，且是不可变类型。字典是无序的 set 3) 判断数据类型 type() 不会认为子类是一种父类类型 isinstance() 会认为子类是一种父类类型 ####5. 运算符 1) 算术运算符 + - * /真正的除法，非地板除 % //用于地板除 2) 比较运算符 == != > &lt; >= &lt;= 3) 赋值运算 = += -= *= /= %= **= //= 4) 位运算符 &amp; | ^ ~~x类似于~x-1 >&gt; &lt;&lt; 5) 逻辑运算符 andx and y 如果x为False, 返回False否则返回y的计算值 orx or y 如果x为True, 返回x的值，否则返回y的计算值 not 6) 成员运算符 in not in 7) 身份运算符 isx is y类似id(x) == id(y)如果引用的是同一个对象返回True,否则返回False not is x not is y类似id(x) != id(y)如果引用的不是同一个对象返回True,否则返回False 与==或!=的区别 is和not is判断的是两个变量引用对象，==和!=判断的是引用变量的值 8) 运算符优先级 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ \ 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 6. 数字(Number)1) 常见数字类型举例 int float complex 10 0.0 3.14j 100 15.20 45.j -786 -21.9 9.322e-36j 080 32.3+e18 .876j -0490 -90. -.6545+0J -0x260 -32.54e100 3e+26J 0x69 70.2-E12 4.53e-7j 2) 数字类型之间的转换 int(x) float(x) complex(x)将x转到一个复数，实部为x，虚部为0 complex(x, y)将x和y转换到一个复数，实部为x，虚部为y, x和y是数字表达式 3) 运算 //得到的并不一定是整数，与分母和分子的数据类型有关系 在不同的机器上浮点数运算的结果可能不同 在交互模式中，最后被输出的表达式结果被赋值给变量_ 4) 随机数函数 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 5) 三角函数 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 6) 数字常亮 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数）。 7. 字符串1) 切片 str[start:end:step] 字符串反转[::-1] 还可以用在tuple和list 2) 获取 str[index] str.index[sub_str] 3) 判断 isalpha()都是字符 isdecimal()都是数字 islower()都是小写字符 isupper()都是大写字符 startswith(str)是否以str开头 endswith(str)是否以str结尾 4) 查找替换 find(str, start=0, end=len(string)) rfind(str, start=0, end=len(string)) index(str, start=0, end=len(string)) rindex(str, start=0, end=len(string)) replace(old_str, new_str, num=string.count(old)) 5) 拆分连接 partition(str)将字符串分成三个元组（str前，str，str后） rpartition(str) split(str=””,num)num有指定值时，分割num+1个字符串​ splitlines()按照(“\r”, “\n”, “\r\n”)分割 str1 + str2 str.join(seq)以str作为分隔符，将seq中的所有元素合并成一个新的字符串 6) 大小写转换 lower() upper() 7) 文本对齐 ​ 长度不够时空格填充 ljust(width) rjust(width) center(width) 8) 去除空白 lstrip() rstrip() strip() 9) 重复 * 还可以用在list和tuple 10) 转换可运算类型 eval(str) 11) 转义字符 转义字符 描述 \(在行尾时) 续行符 \\ 反斜杠符号 \‘ 单引号 \“ 双引号 \a 响铃 \b 退格(Backspace) \e 转义 \000 空 \n 换行 \v 纵向制表符 \t 横向制表符 \r 回车 \f 换页 \oyy 八进制数，yy代表的字符，例如：\o12代表换行 \xyy 十六进制数，yy代表的字符，例如：\x0a代表换行 \other 其它的字符以普通格式输出 12) 原始字符串 r/R’str’ 13) 字符串格式化 符 号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 14) Unicode字符串 在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。 8. 列表1) 添加 insert(索引, 数据)指定的位置前有空元素时会补位 append(数据)将数据作为整体追加到列表 extend(iterable)将可迭代数据拆包后追加到尾部，相当于list1 += iterable 2) 删除 del 列表[索引]直接从内存中删除，同del() 还可以用在其它类型数据 列表.remove(数据)删除第一次出现的元素 列表.pop(索引)不指定索引时，删除最后一个元素 列表.clear()清空列表，列表本身还在 3) 修改 列表[索引] = 数据索引不存在会报错 4) 查询 列表[索引] 列表.index(数据)查询第一次出现的元素的位置.没有会报错 列表.count(数据) if 数据 in 列表 len(列表) 5) 排序 列表.sort()默认升序，列表.sort(reverse=True) 降序 列表.reverse() 9. 元组 只包含一个元素时，需要用逗号隔开 查询 元组[索引] 元组.index(数据) 元组.count(数据) len(列表) if 数据 in 元组 ####10. 字典 1) 添加 字典[键] = 数据 2) 删除 del 字典[键] 字典.pop(键)pop(键, None) 键不存在时不报错，第二个参数为具体的某个值时，会在键不存在时返回该值 字典.clear() 3) 修改 字典[键] = 数据 字典.get(键)键值不存在不会报错 字典.keys() 字典.values() 字典.items() 11. 语句1) 条件控制 if if else if elif else x if ... else ... 2) 循环语句 whilewhile ... else... for for ... in...else... 循环控制 break 和continue 12. 常用函数1) len() 2) max() 3) min() 4) sum() 13. 可变与不可变类型1) 可变类型可以被修改，list，dict，set 2) 不可变类型不可以被修改，str，int，float，bool，tuple 3) 注意对可变类型与不可变类型通过函数操作时，需要开辟新的空间，可变类型原空间数据不变对可变类型调用相应的方法进行操作时，不会重新分配空间，原数据发生变化对不可变类型调用相应方法操作时，需要重新分配空间如：lists = [6, 2, 3, 5] sort(lists) 返回 [2, 3, 5, 6] lists不变 lists.sort() 无返回 lists 变成 [2, 3, 5, 6] 14. 函数 参数必须使用关键字def func(a, *,name) 函数在调用时 name参数必须以关键字参数传入 参数定义时出现的位置位置参数 &gt; *args &gt; 关键字参数 &gt; **kwargs （如果关键字与kwargs中的键值不重复，可以将关键字参数放在kwargs参数后） 匿名函数lambda 参数: 表达式 lambda 只是一个表达式，而不是一个语句块 15. 文件1) 打开文件 open(file_name, mode) 访问模式 r只读，文件指针在文件开头，默认模式 w只写，存在时覆盖，不存在时创建新文件 a追加模式，文件不存在时创建文件 rb wb ab r+ w+ a+ rb+ wb+ ab+ 总结文件不存在时创建文件，w， w+，a，a+，wb，wb+，ab，ab+ 2) 读取数据 read()f.read(num) 不写参数时表示读取所有的数据 readlines()f.readlines() 按照行一次性读取所有的数据，返回的是一个列表 readline()一次读取一行数据 3) 写入数据 write() 4) 关闭文件 f.close() 5) 文件定位读写 tell() 获取当前位置 seek(offset, from) 设置位置 offset：偏移量 from：方向 0 表示文件开头 1 表示当前位置 2 表示文件末尾 6) os 文件操作 文件重命名os.rename(需要修改的文件, 新的文件名) 删除文件os.remove(文件) 创建文件夹os.mkdir(文件夹名) 获取当前目录os.getcwd() 改变默认目录os.chdir(“test”) 跳转到当前路径的test子目录中 获取目录列表os.listdir() 删除文件夹os.rmdir() 目录非空 判断文件是否存在os.path.exists(文件)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
</search>
